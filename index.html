<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Avatar BT</title>
		<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
		<link rel="stylesheet" type="text/css" href="styles.css" />
	</head>
	<body>
		<!-- Console output-->
		<div id="consoleOutput"></div>
		<div id="logoSpace">
			<img class="logo" src="logo.svg" alt="Logo" />
		</div>
		<div id="avatarBTdiv">
			<!-- Connect Button. -->
			<button id="connectButton" class="button" disabled onclick="connecting_Sound.play()">
				<span class="material-icons" style="vertical-align: middle;">bluetooth_searching</span> Connect to Avatar
			</button>
		</div>
		<!-- Div to display status of Avatar BT shop -->
		<div id="closestShop"></div>
		<!-- Coordinates-->
		<div id="currentLocation"></div>
		<!-- Movement>-->
		<div id="messageDisplayDiv">
			<button id="dismissButton" onclick="dismissMessage()">Dismiss</button>
		</div>
		<script>
			//Script for pairing with Avatar_BT
			let characteristic;
			let isConnected = false; // Track connection state
			let device; // Declare device variable.
			var message;
			let partMoving = "";
			let directionMoving = "";
			let patternMovement ="";
			var blueToothStatus = "Avatar Offline";
			var streetName = "Unknown";
			var deviceName ="";
			let labels = ["EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY",];
			let moveSource = null;
			let movePatterns = null;
			let sentenceSource = null;
			let tagSource = null;

			var alert_Sound = new Howl({
			src: ['audio/alert_high-intensity.ogg'],
			html5: true,
			volume: 0.5, // Adjust volume as needed (0 to 1)
			onloaderror: function(error) {
					console.error('Error loading audio:', error);
				},
			});

			var success_Sound = new Howl({
			src: ['audio/navigation_selection-complete-celebration.ogg'],
			html5: true,
			volume: 0.5, // Adjust volume as needed (0 to 1)
				onloaderror: function(error) {
					console.error('Error loading audio:', error);
				},
			});

			var connecting_Sound = new Howl({
			src: ['audio/ui_loading.ogg'],
			html5: true,
			volume: 0.5, // Adjust volume as needed (0 to 1)
				onloaderror: function(error) {
					console.error('Error loading audio:', error);
				},
			});


			async function connectToDevice() {
				try {
					if (!isConnected) {
						// Request Bluetooth device
						device = await navigator.bluetooth.requestDevice({
							filters: [{ services: ["6e400001-b5a3-f393-e0a9-e50e24dcca9e"] }],
						});
						// Connect to the selected device
						const server = await device.gatt.connect();
						// Get UART service
						const service = await server.getPrimaryService("6e400001-b5a3-f393-e0a9-e50e24dcca9e");
						// Get UART characteristic
						characteristic = await service.getCharacteristic("6e400003-b5a3-f393-e0a9-e50e24dcca9e");
						// Start notifications for the characteristic
						await characteristic.startNotifications();
						 // Get the device name
						deviceName = device.name;

						if (deviceName === "hachi_BT") {
							console.log("Loading settings for Hachi_BT");
							labels = ["EMPTY", "EMPTY", "EMPTY", "EMPTY", "HEAD", "FRONT LEG", "TAIL", "BACK LEG"];
							moveSource = 'hachi_moves.json';
							movePatterns = 'hachi_patterns.json';
							sentenceSource = 'hachi_sentences.json';
							tagSource = 'tags.json';
						} else {
							console.log("Loading settings for Avatar_BT");
							labels = ["LEFT FOREARM", "LEFT SHOULDER", "HEAD", "RIGHT SHOULDER", "RIGHT FOREARM", "WAIST", "LEFT LEG", "RIGHT LEG"];
							moveSource = 'avatar_moves.json';
							movePatterns = 'avatar_patterns.json';
							sentenceSource = 'avatar_sentences.json';
							tagSource = 'tags.json';
						}
						// Listen for characteristic value changes
						characteristic.addEventListener("characteristicvaluechanged", handleCharacteristicValueChanged);
						// Update UI
						document.getElementById("connectButton").innerHTML = '<span class="material-icons" style="vertical-align: middle;">bluetooth_connected</span> Disconnect Avatar';
						isConnected = true;
						setTimeout(function() {
							startDetectMovement = true;
							blueToothStatus = "Avatar Online";
						}, 4000);
					} else {
						// Disconnect from the device
						await characteristic.stopNotifications();
						await device.gatt.disconnect();
						isConnected = false;
						document.getElementById("connectButton").innerHTML = '<span class="material-icons" style="vertical-align: middle;">bluetooth_searching </span> Connect to Avatar';
						// Set all potValues to 0
						setTimeout(function() {
							startDetectMovement = false;
							potValues = [0, 0, 0, 0, 0, 0, 0, 0, 0];
							blueToothStatus = "Avatar Offline";
						}, 4000);
					}
				} catch (error) {
					console.error("Error connecting/disconnecting: " + error);
				}
			}
			// Attach click event listener to button.
			document.getElementById("connectButton").addEventListener("click", connectToDevice);
			// Function to handle incoming data from UART
			function handleCharacteristicValueChanged(event) {
				const value = event.target.value;
				// Convert the received data to a string
				const textDecoder = new TextDecoder();
				const decodedValue = textDecoder.decode(value);
				// Pass the received data to Processing sketch
				receiveData(decodedValue);
			}
			// Function to receive data from JavaScript
			function receiveData(data) {
				if (window.receiveDataFromSerial) {
					window.receiveDataFromSerial(data);
				} else {
					console.error("Processing sketch not initialized.");
				}
			}

			function checkVariables() {
				// Check if latitude, longitude, and weatherDescription are not null
				if (latitude !== null && longitude !== null && weatherDescription !== null) {
					fetchStreetName().then((name) => {
						streetName = name;
						connectButton.disabled = false;
						displayText("Ready to connect to Avatar BT");
						});
				} else {
					// If any variable is still null, wait for a short delay and check again
					setTimeout(checkVariables, 1000); // Adjust delay as needed (here 1000 milliseconds or 1 second)
				}
			}

			// Call the function when the script is loaded
			window.onload = checkVariables;

			// Function to redirect console.log and console.error to a div
			function redirectConsoleToDiv() {
				var consoleOutputDiv = document.getElementById('consoleOutput');
				if (!consoleOutputDiv) {
					console.error("Div for console output not found");
					return;
				}

				// Save the original console.log and console.error functions
				var originalConsoleLog = console.log;
				var originalConsoleError = console.error;

				// Override console.log to append messages to the div
				console.log = function(...args) {
					originalConsoleLog(...args);
					var consoleMessage = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' '); // Convert objects to strings
					consoleOutputDiv.innerHTML = '<div class="log">'+"<strong>DEBUG CONSOLE LOG:</strong> " + consoleMessage + '</div>';
				};

				// Override console.error to append error messages to the div
				console.error = function(...args) {
					originalConsoleError(...args);
					var consoleMessage = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' '); // Convert objects to strings
					consoleOutputDiv.innerHTML = '<div class="error">'+ "<strong>DEBUG CONSOLE ERROR:</strong> " + consoleMessage + '</div>';
				};
			}

			// Call the function to redirect console.log and console.error to the div
			redirectConsoleToDiv();
		</script>

		<script>
			var latitude;
			var longitude;
			let speed;
			function getCurrentLocation() {
				if (navigator.geolocation) {
					const options = {
						enableHighAccuracy: true,
					};
					let previousPosition = null;
					let totalDistance = 0;
					navigator.geolocation.watchPosition(
						function (position) {
							latitude = position.coords.latitude; // Store latitude globally
							longitude = position.coords.longitude; // Store longitude globally
							console.log("Location is longitude: " + longitude + " latitude: "+ latitude );
							const speedThreshold = 0.5; // Threshold for considering the user as significantly moving (in meters per second)
							speed = position.coords.speed || 0; // Speed in meters per second
							// Reset total distance if speed is less than threshold
							if (speed < speedThreshold) {
								totalDistance = 0;
							} else if (previousPosition) {
								const distance = calculateDistance(
									previousPosition.coords.latitude,
									previousPosition.coords.longitude,
									position.coords.latitude,
									position.coords.longitude
								);
								totalDistance += distance;
							}
							previousPosition = position;
							let heading = position.coords.heading || 0; // Heading in degrees
							// Determine direction text based on heading
							let directionText;
							if (speed >= speedThreshold) {
								if (heading >= 337.5 || heading < 22.5) {
									directionText = "Heading North";
								} else if (heading >= 22.5 && heading < 67.5) {
									directionText = "Heading Northeast";
								} else if (heading >= 67.5 && heading < 112.5) {
									directionText = "Heading East";
								} else if (heading >= 112.5 && heading < 157.5) {
									directionText = "Heading Southeast";
								} else if (heading >= 157.5 && heading < 202.5) {
									directionText = "Heading South";
								} else if (heading >= 202.5 && heading < 247.5) {
									directionText = "Heading Southwest";
								} else if (heading >= 247.5 && heading < 292.5) {
									directionText = "Heading West";
								} else if (heading >= 292.5 && heading < 337.5) {
									directionText = "Heading Northwest";
								}
							} else {
								directionText = "Not moving";
							}
							// Update the HTML element with the direction and distance walked
							document.getElementById("currentLocation").innerHTML =
								"<strong><span class='material-icons' style='vertical-align: middle;'>bluetooth</span> Bluetooth:</strong> " + blueToothStatus +
								" <strong><span class='material-icons' style='vertical-align: middle;'>place</span> Latitude:</strong> " + latitude +
								"<strong> Longitude:</strong> " + longitude + "<br>" +
								"<strong><span class='material-icons' style='vertical-align: middle;'>location_city</span> Nearest street:</strong> " + streetName +
								" <strong><span class='material-icons' style='vertical-align: middle;'>explore</span> Direction:</strong> " + directionText + "<br>" +
								"<strong><span class='material-icons' style='vertical-align: middle;'>speed</span> Speed:</strong> " + speed.toFixed(2) + "ms/s" +
								"<strong><span class='material-icons' style='vertical-align: middle;'>directions_walk</span> Distance Walked: </strong> " + totalDistance.toFixed(2) +
								" m <strong>Avatar Actions:</strong> "+ partMoving + " " + directionMoving;
						},
						function (error) {
							console.error("Error getting current location: ", error);
						},
						options
					);
				} else {
					console.error("Geolocation is not supported by this browser.");
				}
			}
			// Function to calculate the distance between two coordinates using Haversine formula.
			function calculateDistance(lat1, lon1, lat2, lon2) {
				const earthRadius = 6371e3; // Earth radius in meters
				const phi1 = (lat1 * Math.PI) / 180; // Latitude in radians
				const phi2 = (lat2 * Math.PI) / 180; // Latitude in radians
				const deltaPhi = ((lat2 - lat1) * Math.PI) / 180;
				const deltaLambda = ((lon2 - lon1) * Math.PI) / 180;
				const a =
					Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);
				const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
				const distance = earthRadius * c; // Distance in meters
				return distance;
			}
			getCurrentLocation();

			function calculateDistance(lat1, lon1, lat2, lon2) {
				var R = 6371e3; // metres
				var φ1 = (lat1 * Math.PI) / 180; // φ, λ in radians
				var φ2 = (lat2 * Math.PI) / 180;
				var Δφ = ((lat2 - lat1) * Math.PI) / 180;
				var Δλ = ((lon2 - lon1) * Math.PI) / 180;
				var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
				var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
				var d = R * c; // in metres
				return d;
			}
		</script>

		<script type="text/javascript">
			// Processing 4 sketch to visualize movements of the Avatar.
			let numPotentiometers = 8;
			let potValues;
			let lineColors;
			let backgroundColors;
			let isMovingUp = false;
			let isMovingDown = false;
			var previousPotValues = new Array(numPotentiometers);
			const cooldownDuration = 500; // 1 second
			let detectMovement = true;
			let startDetectMovement = false;
			let tagID;

			function setup() {
				var avatarBTCanvas = createCanvas(windowWidth, windowHeight * 0.5);
				avatarBTCanvas.parent("avatarBTdiv");
				potValues = [0, 0, 0, 0, 0, 0, 0, 0]; // Initialize potValues array with default values
				lineColors = new Array(numPotentiometers);
				backgroundColors = new Array(numPotentiometers);
				setupColors();
				setupBackgroundColors();
			}
			function draw() {
				background(255);
				let lineHeight = height / numPotentiometers;
				let labelSize = min(width, height) * 0.03; // Responsive font size for labels
				for (let i = 0; i < numPotentiometers; i++) {
					let lineY = i * lineHeight + lineHeight / 2;
					// Draw the background rectangle
					noStroke();
					fill(backgroundColors[i]);
					rect(0, i * lineHeight, width, lineHeight);
					// Draw the line with different color for each
					strokeWeight(40);
					stroke(lineColors[i]);
					line(0, lineY, map(potValues[i], 0, 4095, 0, width * 0.55), lineY);
					// Display the corresponding value to the left of the line
					noStroke();
					fill(255);
					textFont("Roboto");
					textAlign(RIGHT, CENTER);
					textSize(labelSize);
					text(int(potValues[i]), map(potValues[i], 0, 4095, 0, width * 0.55) - 10, lineY);
				}
				// Draw vertical labels on the right side
				textAlign(RIGHT, CENTER);
				let labelFontSize = min(width, height) * 0.03; // Responsive font size for labels
				textFont("Roboto");
				textSize(labelFontSize);
				fill(255); // Set text color to white
				for (let i = 0; i < numPotentiometers; i++) {
					text(labels[i], width * 0.9, i * lineHeight + lineHeight / 2);
				}
				// Detect movement and display corresponding text
				if (startDetectMovement){
					checkMovement();
				}
			}

			// Function to receive data from JavaScript
			function receiveData(data) {
				let values = data.split(",");
				//console.log(values);
				tagID = values.pop(); // Remove and store the last element as tagID
				readTag();
				if (values.length === numPotentiometers) { // Check if the length of values is 8
					for (let i = 0; i < values.length; i++) {
						potValues[i] = parseFloat(values[i]);
					}
				}
			}

			// Define variables for detecting movement in different body parts
			function handleMovement() {
				// Define thresholds for movement detection
				let movementThreshold = 13;

				// Variables to track movement of different body parts
				let movements = {};

				// Mapping between labels and movements for hachi_BT
				if (deviceName === "hachi_BT") {
					labelMovements = {
						"HEAD": "headMoving",
						"FRONT LEG": "leftLegMoving",
						"BACK LEG": "rightLegMoving",
						"LEFT SHOULDER": "leftShoulderMoving",
						"RIGHT SHOULDER": "rightShoulderMoving",
						"LEFT FOREARM": "leftForearmMoving",
						"RIGHT FOREARM": "rightForearmMoving",
						"TAIL": "waistMoving"
					};
				} else {
					// Default labelMovements object for avatar_BT
					labelMovements = {
						"HEAD": "headMoving",
						"LEFT LEG": "leftLegMoving",
						"RIGHT LEG": "rightLegMoving",
						"LEFT SHOULDER": "leftShoulderMoving",
						"RIGHT SHOULDER": "rightShoulderMoving",
						"LEFT FOREARM": "leftForearmMoving",
						"RIGHT FOREARM": "rightForearmMoving",
						"WAIST": "waistMoving"
					};
				}
				// Check movement for each potentiometer
				for (let i = 0; i < numPotentiometers; i++) {
					let label = labels[i];
					let movement = labelMovements[label];

					if (!movement) continue; // Skip if label not found in labelMovements

					// Movement detection
					if (potValues[i] < previousPotValues[i] - movementThreshold) {
						movements[movement] = true; // Movement increases
					} else if (potValues[i] > previousPotValues[i] + movementThreshold) {
						movements[movement] = false; // Movement decreases
					}
				}
				// Update previous potentiometer values for the next iteration.
				previousPotValues = potValues.slice(0, numPotentiometers);
				// Return the detected movement
				return movements;
			}

			let cachedMovementConditions = null;
			let previousPart = "none";
			let previousDirection = "none";

			async function checkMovement() {
				// Detect movement
				let movements = handleMovement();

				// Fetch movement conditions JSON file if not already cached...
				if (!cachedMovementConditions) {
					try {
						cachedMovementConditions = await $.get(moveSource);
						processMovementConditions(movements);
					} catch (error) {
						console.error('Error fetching movement conditions JSON:', error);
					}
				} else {
					processMovementConditions(movements);
				}

				function processMovementConditions(movements) {
					// Iterate over movement conditions.
					cachedMovementConditions.forEach(condition => {
						let match = true;
						for (let key in condition.condition) {
							if (condition.condition[key] !== movements[key]) {
								match = false;
								break;
							}
						}
						if (match) {
							partMoving = condition.partMoving;
							directionMoving = condition.directionMoving;
						}
					});

					// Check if partMoving or directionMoving are different from their previous values and add movement to the sequence buffer
					if (partMoving !== previousPart || directionMoving !== previousDirection) {
						// Add movement to the sequence buffer
						console.log(partMoving+" "+directionMoving);
						previousPart = partMoving;
						previousDirection = directionMoving;
						trackMovementSequences();
					} else {
						return;
					}
				}
			}

			let movementBuffer = [];
			let cachedMovePatterns;

			// Function to track movement sequences and compare them against patterns
			async function trackMovementSequences() {
				try {
					const currentSequence = { partMoving, directionMoving };

					// Check if the current sequence is different from the previous one
					if (
						movementBuffer.length > 0 &&
						movementBuffer[movementBuffer.length - 1].partMoving === partMoving &&
						movementBuffer[movementBuffer.length - 1].directionMoving === directionMoving
					) {
						return; // Exit early if the sequence is the same as the previous one
					}

					movementBuffer.push(currentSequence);

					// Limit the buffer to store only the last 5 variations
					if (movementBuffer.length > 5) {
						movementBuffer.shift(); // Remove the oldest variation
					}

					const patterns = await fetchJSONFile(movePatterns, cachedMovePatterns);
					//const patterns = await fetchMovementPatterns();
					for (const pattern of patterns) {
						if (checkPatternInBuffer(pattern.pattern)) {
							success_Sound.play();
							console.log(`Pattern matched: ${pattern.patternName}`);
							patternMovement = pattern.patternName;
							displayText(patternMovement);
							// Optionally, you can clear the buffer after a match if needed
							movementBuffer = [];
							return;
						}
					}
				} catch (error) {
					console.error(error);
				}
			}

			// Function to check if a pattern exists in the movement buffer
			function checkPatternInBuffer(pattern) {
				const bufferLength = movementBuffer.length;
				if (bufferLength < pattern.length) {
					return false; // Not enough movements in the buffer for pattern matching
				}

				// Check the last 'pattern.length' movements in the buffer
				const bufferSlice = movementBuffer.slice(-pattern.length);
				for (let i = 0; i < pattern.length; i++) {
					if (pattern[i].partMoving !== bufferSlice[i].partMoving ||
						pattern[i].directionMoving !== bufferSlice[i].directionMoving) {
						return false; // Pattern doesn't match
					}
				}
				return true; // Pattern matched
			}

			let cachedPatterns; // Variable to cache the fetched patterns data
			async function fetchMovementPatterns() {
				try {
					if (cachedPatterns) {
						// If data is already cached, return it immediately
						return cachedPatterns;
					} else {
						// If data is not cached, fetch it from the server
						const patterns = await $.get(movePatterns);
						cachedPatterns = patterns; // Cache the fetched data
						return patterns;
					}
				} catch (error) {
					console.error(error);
					return []; // Return an empty array in case of error
				}
			}

			// Function to fetch city name using Overpass API
			function fetchStreetName() {
				return new Promise((resolve, reject) => {
					const checkCoordinates = () => {
						if (typeof latitude !== "undefined" && typeof longitude !== "undefined" && latitude !== 0 && longitude !== 0) {
							resolve();
						} else {
							setTimeout(checkCoordinates, 300); // Check again after 100 milliseconds
							console.log("Fetching location...");
						}
					};
					checkCoordinates();
					// Log the street promise to the console
					console.log("Fetching street data...");
				})
				.then(() => {
					// Construct Overpass API query
					var overpassQuery = "https://overpass-api.de/api/interpreter?data=[out:json];node(around:50," + latitude + "," + longitude + ");out;";
					// Fetch data from Overpass API
					return fetch(overpassQuery);
				})
				.then((response) => response.json())
				.then((data) => {
					// Loop through elements to find 'addr:street' property
					for (let i = 0; i < data.elements.length; i++) {
						const element = data.elements[i];
						if (element.tags && element.tags['addr:street']) {
							console.log("Street name:", element.tags['addr:street']);
							return element.tags['addr:street']; // Found, return street name
						}
					}
					// If 'addr:street' is not found in any element, throw an error.
					throw new Error("Street name not found");
				})
				.catch((error) => {
					//console.error("Error fetching street name:", error);
					return "an unknown";
				});
			}

			// Define a function to fetch the street name and update the global variable
			function updateStreetName() {
				if (isConnected) {
					fetchStreetName()
						.then((name) => {
							streetName = name;
						})
						.catch(error => {
							console.error(error);
						});
				}
			}

			// Call updateStreetName then every 10 seconds
			setInterval(updateStreetName, 30000); // Call it every 10 seconds (10000 milliseconds)

			var timeoutID; // Variable to hold the timeout ID.
			var previousMessage = ""; // Variable to store the previous message
			var previousLatitude;
			var previousLongitude;
			var previousPartMoving;
			var previousDirectionMoving;
			var timeOfDay = getTimeOfDay();

			var fullMessage;

			function displayText(message) {
				var messageDisplayDiv = document.getElementById("messageDisplayDiv");
				fullMessage = message;

				// Check if speaking is true, if so, exit early
				if (speaking) {
					return;
				}

				clearTimeout(timeoutID);

				// Check if partMoving or directionMoving has changed
				if (partMoving !== previousPartMoving || directionMoving !== previousDirectionMoving) {
					// Update previous partMoving and directionMoving.
					previousPartMoving = partMoving;
					previousDirectionMoving = directionMoving;

					// Check if latitude or longitude has changed
					if (latitude !== previousLatitude || longitude !== previousLongitude) {
						// Update previous latitude and longitude
						previousLatitude = latitude;
						previousLongitude = longitude;
						console.log("new position");
						composeMessage(message, weatherDescription, timeOfDay, name, partMoving, directionMoving,latitude,longitude,speed,patternMovement)
								.then((fullMessage) => {
									updateDisplay(fullMessage);
									streetName = name;
								})
								.catch(error => {
									console.error(error);
								});
						};
					} else {
						// Compose the full message using the existing streetName value
						composeMessage(message, weatherDescription, timeOfDay, streetName, partMoving, directionMoving,latitude,longitude,speed,patternMovement)
							.then((fullMessage) => {
								updateDisplay(fullMessage);
							})
							.catch(error => {
								console.error(error);
							});
					}
				}

				function dismissMessage() {
					// Clear the text content of the message display div
					document.getElementById("messageDisplayDiv").textContent = "";

					// Hide the message display div
					document.getElementById("messageDisplayDiv").style.display = "none";
				}

				// Update display
				function updateDisplay(displayMessage) {
					try {
						// Set the text content
						messageDisplayDiv.textContent = fullMessage;
						speakMessage(fullMessage);

						// Check if message is not empty to show the overlay
						messageDisplayDiv.style.display = fullMessage.trim() !== "" ? "block" : "none";

						// Set a timeout to clear the text after 3 seconds or until speaking becomes false
						var timeoutCallback = function() {
							if (!speaking) {
								messageDisplayDiv.textContent = ""; // Clear the text
								messageDisplayDiv.style.display = "none"; // Hide the overlay after clearing the text
							} else {
								timeoutID = setTimeout(timeoutCallback, 1000); // Check again after 1 second
							}
						};
						timeoutID = setTimeout(timeoutCallback, 3000);
					} catch (error) {
						// Catch and log any errors that occur within the function
						console.error("An error occurred:", error);
					}
				}

			// Function to compose the message

			async function fetchJSONFile(filename, cachedVariable) {
				try {
					if (!cachedVariable) {
						const response = await fetch(filename);
						if (!response.ok) {
							throw new Error('Network response was not ok');
						}
						const jsonData = await response.json(); // Fetch JSON data
						cachedVariable = jsonData; // Cache the fetched JSON data in the specified variable
						return jsonData;
					} else {
						return cachedVariable; // Return cached data if available
					}
				} catch (err) {
					console.error('Error fetching JSON file:', err);
					return null;
				}
			}

			let cachedSentences;
			async function composeMessage(template, weatherDescription, timeOfDay, name, partMoving, directionMoving,latitude,longitude,patternMovement) {
				try {
					let sentenceTemplate;
					if (noNarrative) {
						// Read sentences from JSON file.
						const sentences = await fetchJSONFile(sentenceSource, cachedSentences);
						if (!sentences || !Array.isArray(sentences) || sentences.length === 0) {
							throw new Error("Error: Unable to load or empty sentences array.");
						}

						// Select a random sentence object from the array
						const randomSentenceObject = sentences[Math.floor(Math.random() * sentences.length)];

						// Ensure that the random sentence object has the "sentence" property and it's a string
						if (!randomSentenceObject || typeof randomSentenceObject.sentence !== 'string') {
							throw new Error("Error: Random sentence object is invalid.");
						}

						// Extract the sentence template from the random sentence object
						sentenceTemplate = randomSentenceObject.sentence;
					} else {
						// If noNarrative is set to true, keep the original message template
						sentenceTemplate = template;
					}
					// Replace placeholders in the sentence template
					fullMessage = sentenceTemplate
						.replace(/\{weatherDescription\}/g, weatherDescription)
						.replace(/\{timeOfDay\}/g, timeOfDay)
						.replace(/\{name\}/g, name)
						.replace(/\{partMoving\}/g, partMoving)
						.replace(/\{directionMoving\}/g, directionMoving)
						.replace(/\{speed\}/g, speed)
						.replace(/\{patternMovement\}/g, patternMovement)
						.replace(/\{latitude\}/g, latitude)
						.replace(/\{longitude\}/g, longitude);

					return fullMessage;
				} catch (err) {
					console.error('Error fetching or composing message:', err);
					return null;
				}
			}

			// Variable to store the last spoken message
			let lastSpokenMessage = '';
			let speaking = false;

			function speakMessage(fullMessage) {
			// Check if the message is the same as the last spoken message
				if (fullMessage === lastSpokenMessage) {
					console.log("Message already spoken.");
					return; // Exit the function without speaking again
				}
				// Check if currently speaking
				if (speaking) {
					console.log("Already speaking, new message ignored.");
					return;
				}
				// Create a new instance of SpeechSynthesisUtterance.
				const utterance = new SpeechSynthesisUtterance(fullMessage);
				// Filter available voices to find Karen's voice in Australian English
				const karenVoice = speechSynthesis.getVoices().find(voice => voice.name === 'Karen' && voice.lang === 'en-AU');
				// Set the voice to Karen's voice if found, otherwise use the default voice
				utterance.voice = karenVoice || speechSynthesis.getVoices()[0];
				// Speak the message
				speechSynthesis.speak(utterance);
				utterance.onstart = function() {
					speaking = true;
					console.log("Currently speaking");
					// Update the last spoken message
					lastSpokenMessage = fullMessage;
				};
				utterance.onend = function() {
					console.log("End speaking");
					speaking = false;
				}
				// Event handler for speech synthesis error
				utterance.onerror = function(event) {
					speaking = false; // Reset speaking flag
					console.error("Speech synthesis error:", event.error);
				};
			}

			function checkSpeechSynthesis() {
				// Check if speechSynthesis object is available
				if ('speechSynthesis' in window) {
					// Check if speaking flag is true
					if (speechSynthesis.speaking) {
						speaking = true;
					} else {
						speaking = false;
					}
				} else {
					console.log("Speech synthesis is not supported in this browser.");
				}
			}

			// Call the function periodically (e.g., every 5 seconds)
			setInterval(checkSpeechSynthesis, 1000); // Adjust the interval as needed

			let weatherDescription = null;
			// Define fetchWeather function
			function fetchWeather() {
				// Define a promise to fetch weather description
				const weatherPromise = new Promise((resolve, reject) => {
					const checkCoordinates = () => {
						if (typeof latitude !== "undefined" && typeof longitude !== "undefined" && latitude !== 0 && longitude !== 0) {

							resolve();
						} else {
							console.log("Fetching location");
							setTimeout(checkCoordinates, 100); // Check again after 100 milliseconds
						}
					};
					checkCoordinates();
				})
				.then(() => {
					const apiKey = '21b99074efb73ba35f476f78f1b018ec';
					const apiUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&appid=${apiKey}`;
					// Fetch data from OpenWeather API
					return fetch(apiUrl);
				})
				.then(response => {
					if (!response.ok) {
						throw new Error('Failed to fetch weather data');
					}
					return response.json();
				})
				.then(data => {
					// Extract the weather description and store it globally
					weatherDescription = data.weather[0].description;
					return weatherDescription;
				})
				.catch(error => {
					console.error('Error fetching weather data:', error);
					throw error; // Rethrow the error to be caught by the caller if needed
				});

				// Log the weather promise to the console
				console.log("Fetching weather data...");

				// Use the weather promise elsewhere in your code if needed
				weatherPromise.then((weatherDescription) => {
					console.log("Weather description:", weatherDescription);
				});

				// Return the weather promise
				return weatherPromise;
			}
			fetchWeather();

			// Function to determine if it's day or night
			function getTimeOfDay() {
				var currentTime = new Date().getHours();
				if (currentTime >= 6 && currentTime < 9) {
					return "early morning";
				} else if (currentTime >= 9 && currentTime < 12) {
					return "morning";
				} else if (currentTime >= 12 && currentTime < 15) {
					return "noon";
				} else if (currentTime >= 15 && currentTime < 18) {
					return "afternoon";
				} else if (currentTime >= 18 && currentTime < 21) {
					return "evening";
				} else {
					return "night";
				}
			}

			var noNarrative;
			var previousTagID = ""; // Variable to store the previous tagID

			let cachedTagInfo;
			async function readTag() {
				try {
					if (tagID === previousTagID || tagID === "0" || speaking) {
						// If tagID is the same as the previous one or is 0, do nothing
						return;
					} else {
						// Fetch tag information asynchronously
						const tagInfo = await fetchJSONFile(tagSource, cachedTagInfo);

						if (tagInfo && tagInfo.tags.hasOwnProperty(tagID)) {
							// Update previousTagID to the current tagID
							previousTagID = tagID;
							success_Sound.play();
							console.log(tagID);

							// Retrieve tag information based on tagID
							const tagData = tagInfo.tags[tagID];

							// Update variables based on fetched tagData
							if (tagData.variable && typeof tagData.boolean === 'boolean') {
								// Dynamically update variables based on tagData
								window[tagData.variable] = tagData.boolean;
							}
							displayText(tagData.displayText);
							//partMoving = tagData.partMoving;
							//directionMoving = tagData.directionMoving;


						} else {
							alert_Sound.play();
							console.error('Tag information not found.');
							return;
						}
					}
				} catch (err) {
					console.error('Error reading tag:', err);
				}
			}

			function setupColors() {
				lineColors[0] = color(204, 204, 0); // Dark Yellow
				lineColors[1] = color(204, 204, 0); // Dark Yellow
				lineColors[2] = color(255, 0, 0); // Red
				lineColors[3] = color(204, 204, 0); // Dark Yellow
				lineColors[4] = color(204, 204, 0); // Dark Yellow
				lineColors[5] = color(0, 255, 0); // Bright Green
				lineColors[6] = color(0, 128, 0); // Grass Green
				lineColors[7] = color(0, 128, 0); // Grass Green
			}
			function setupBackgroundColors() {
				backgroundColors[0] = color(0, 0, 0); // 0% black
				backgroundColors[1] = color(0, 0, 0); // 0% black
				backgroundColors[2] = color(0, 0, 0, 200); // 90% black
				backgroundColors[3] = color(0, 0, 0, 230); // 75% black
				backgroundColors[4] = color(0, 0, 0, 230); // 60% black
				backgroundColors[5] = color(0, 0, 0, 128); // 60% black
				backgroundColors[6] = color(0, 0, 0, 100); // 60% black
				backgroundColors[7] = color(0, 0, 0, 100); // 60% black
			}
		</script>
	</body>
</html>
