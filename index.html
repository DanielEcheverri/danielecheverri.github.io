<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Searching for Us</title>
		<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
		<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
		<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>

		<link rel="stylesheet" type="text/css" href="styles.css" />
	</head>
	<body>
		<!-- Checkbox for Hachi -->
		<div id="hachiCheckboxContainer">
			<input type="checkbox" id="hachiCheckbox" onclick="toggleDeviceName()" />
		</div>
		<!-- Console output-->
		<div id="consoleOutput"></div>
		<div id="logoSpace">
			<img class="logo" src="logo.svg" alt="Logo" />
		</div>
		<div id="avatarBTdiv">
			<!-- Connect Button. -->
			<button id="connectButton" class="button" disabled onclick="connecting_Sound.play(), wakeLock(), displayText('Connecting')">
				<span class="material-icons" style="vertical-align: middle;">bluetooth_searching</span> Connect to Avatar
			</button>
		</div>
		<!-- Div to display status of Avatar BT shop -->
		<div id="closestShop"></div>
		<!-- Coordinates-->
		<div id="currentLocation"></div>
		<!-- Movement>-->
		<div id="messageDisplayDiv"></div>
		<script>
				//Script for pairing with Avatar_BT
				let characteristic;
				let isConnected = false; // Track connection state
				let device; // Declare device variable.
				var message;
				let partMoving = "none";
				let directionMoving = "none";
				let patternMovement ="none";
				var blueToothStatus = "Offline";
				var streetName = "Unknown";
				var deviceName ="";
				let labels = ["EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY","EMPTY",];
				let moveSource = null;
				let movePatterns = null;
				let sentenceSource = null;
				let tagSource = null;
				let checkpointsSource = 'points.json';

				var connecting_Sound = new Howl({src: ['audio/ui_loading.mp3'],
				onloaderror: function(error) {console.error('Error loading audio:', error);},});

				async function initializeSounds() {
					try {
						const sounds = await fetchJSONFile('sounds.json', window.sounds); // Load JSON file
						if (sounds) {
						for (var key in sounds) {
							if (sounds.hasOwnProperty(key)) {
							window[key] = new Howl({
								src: [sounds[key].src],
								onloaderror: function(error) { console.error('Error loading audio:', error); }
							});
							}
						}
						} else {
						console.error('Failed to load sounds.');
						}
					} catch (error) {
						console.error('Error initializing sounds:', error);
					}
				}

				function toggleDeviceName() {
					var checkbox = document.getElementById("hachiCheckbox");
					if (checkbox.checked) {
						deviceName = "hachi_BT";
						console.log("Setting to "+deviceName);
						console.log("Loading settings for Hachi_BT");
						moveSource = 'hachi_moves.json';
						movePatterns = 'hachi_patterns.json';
						sentenceSource = 'hachi_sentences.json';
						tagSource = 'tags.json';
						initializeSounds();
					} else {
						deviceName = "avatar_BT";
						console.log("Setting to "+deviceName);
						console.log("Loading settings for Avatar_BT");
						moveSource = 'avatar_moves.json';
						movePatterns = 'avatar_patterns.json';
						sentenceSource = 'avatar_sentences.json';
						tagSource = 'tags.json';
						initializeSounds();
					}
				}

				async function connectToDevice() {
					try {
						if (!isConnected) {
							// Request Bluetooth device
							device = await navigator.bluetooth.requestDevice({
								filters: [{ services: ["6e400001-b5a3-f393-e0a9-e50e24dcca9e"] }],
							});
							// Connect to the selected device
							const server = await device.gatt.connect();
							// Get UART service
							const service = await server.getPrimaryService("6e400001-b5a3-f393-e0a9-e50e24dcca9e");
							// Get UART characteristic
							characteristic = await service.getCharacteristic("6e400003-b5a3-f393-e0a9-e50e24dcca9e");
							// Start notifications for the characteristic
							await characteristic.startNotifications();
							 // Get the device name
							deviceName = device.name;

							if (deviceName === "hachi_BT") {
								console.log("Loading settings for Hachi_BT");
								labels = ["EMPTY", "EMPTY", "EMPTY", "EMPTY", "HEAD", "FRONT LEG", "TAIL", "BACK LEG"];
								moveSource = 'hachi_moves.json';
								movePatterns = 'hachi_patterns.json';
								sentenceSource = 'hachi_sentences.json';
								tagSource = 'tags.json';
								initializeSounds();
							} else {
								console.log("Loading settings for Avatar_BT");
								labels = ["LEFT FOREARM", "LEFT SHOULDER", "HEAD", "RIGHT SHOULDER", "RIGHT FOREARM", "WAIST", "LEFT LEG", "RIGHT LEG"];
								moveSource = 'avatar_moves.json';
								movePatterns = 'avatar_patterns.json';
								sentenceSource = 'avatar_sentences.json';
								tagSource = 'tags.json';
								initializeSounds();
							}
							// Listen for characteristic value changes
							characteristic.addEventListener("characteristicvaluechanged", handleCharacteristicValueChanged);
							// Update UI
							document.getElementById("connectButton").innerHTML = '<span class="material-icons" style="vertical-align: middle;">bluetooth_connected</span> Disconnect Avatar';
							isConnected = true;
							setTimeout(function() {
								startDetectMovement = true;
								blueToothStatus = "Online";
							}, 4000);
						} else {
							// Disconnect from the device
							await characteristic.stopNotifications();
							await device.gatt.disconnect();
							isConnected = false;
							document.getElementById("connectButton").innerHTML = '<span class="material-icons" style="vertical-align: middle;">bluetooth_searching </span> Connect to Avatar';
							// Set all potValues to 0
							setTimeout(function() {
								startDetectMovement = false;
								potValues = [0, 0, 0, 0, 0, 0, 0, 0, 0];
								blueToothStatus = "Offline";
							}, 4000);
						}
					} catch (error) {
						console.error("Error connecting/disconnecting: " + error);
					}
				}
				// Attach click event listener to button.
				document.getElementById("connectButton").addEventListener("click", connectToDevice);
				// Function to handle incoming data from UART
				function handleCharacteristicValueChanged(event) {
					const value = event.target.value;
					// Convert the received data to a string
					const textDecoder = new TextDecoder();
					const decodedValue = textDecoder.decode(value);
					// Pass the received data to Processing sketch
					receiveData(decodedValue);
				}
				// Function to receive data from JavaScript
				function receiveData(data) {
					if (window.receiveDataFromSerial) {
						window.receiveDataFromSerial(data);
					} else {
						console.error("Processing sketch not initialized.");
					}
				}

				function wakeLock() {
					if ('wakeLock' in navigator) {
								navigator.wakeLock.request('screen').then(() => {
									console.log('Screen wake lock activated');
								}).catch((err) => {
									console.error('Failed to activate wake lock:', err);
								});
							} else {
								console.warn('Wake lock API not supported');
							}
				}

				function checkVariables() {
					// Check if latitude, longitude, and weatherDescription are not null
					if (latitude !== null && longitude !== null) {
						connectButton.disabled = false;
						initializeSounds();
						displayText("Ready to connect to Avatar BT");
					} else {
						// If any variable is still null, wait for a short delay and check again
						setTimeout(checkVariables, 1000); // Adjust delay as needed (here 1000 milliseconds or 1 second)
					}
				}

				// Call the function when the script is loaded
				window.onload = checkVariables;

				function redirectConsoleToDiv() {
				var consoleOutputDiv = document.getElementById('consoleOutput');
				if (!consoleOutputDiv) {
					console.error("Div for console output not found");
					return;
				}

				// Save the original console.log and console.error functions.
				var originalConsoleLog = console.log;
				var originalConsoleError = console.error;

				var logMessages = []; // Array to store log messages
				var errorMessages = []; // Array to store error messages

				// Override console.log to append messages to the div.
				console.log = function(...args) {
					originalConsoleLog(...args);
					var consoleMessage = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' '); // Convert objects to strings
					logMessages.push("<strong>DEBUG CONSOLE LOG:</strong> " + consoleMessage);
					updateConsoleOutput();
				};

				// Override console.error to append error messages to the div
				console.error = function(...args) {
					originalConsoleError(...args);
					var consoleMessage = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' '); // Convert objects to strings
					errorMessages.push("<strong>DEBUG CONSOLE ERROR:</strong> " + consoleMessage);
					updateConsoleOutput();
				};

				// Function to update the console output with the last two messages
				function updateConsoleOutput() {
					var combinedMessages = logMessages.concat(errorMessages);
					var lastTwoMessages = combinedMessages.slice(-2); // Get the last two messages
					consoleOutputDiv.innerHTML = lastTwoMessages.map(msg => '<div class="log">' + msg + '</div>').join('');
				}
			}

				// Call the function to redirect console.log and console.error to the div
				redirectConsoleToDiv();
		</script>

		<script>
			var latitude;
			var longitude;
			let speed;
			var distEachOther = 0;
			let directionText = "Not moving"

			function getCurrentLocation() {
				if (navigator.geolocation) {
					const options = {
						enableHighAccuracy: true,
					};
					let previousPosition = null;
					let totalDistance = 0;
					navigator.geolocation.watchPosition(
						function (position) {
							latitude = position.coords.latitude.toFixed(6); // Store latitude globally
							longitude = position.coords.longitude.toFixed(6); // Store longitude globally
							console.log("Location is longitude: " + longitude + " latitude: "+ latitude );
							const speedThreshold = 0.5; // Threshold for considering the user as significantly moving (in meters per second)
							speed = position.coords.speed || 0; // Speed in meters per second
							// Reset total distance if speed is less than threshold
							if (speed < speedThreshold) {
								totalDistance = 0;
							} else if (previousPosition) {
								const distance = calculateDistance(
									previousPosition.coords.latitude,
									previousPosition.coords.longitude,
									position.coords.latitude,
									position.coords.longitude
								);
								totalDistance += distance;
							}
							previousPosition = position;
							let heading = position.coords.heading || 0; // Heading in degrees
							// Determine direction text based on heading

							if (speed >= speedThreshold) {
								if (heading >= 337.5 || heading < 22.5) {
									directionText = "Heading North";
								} else if (heading >= 22.5 && heading < 67.5) {
									directionText = "Heading Northeast";
								} else if (heading >= 67.5 && heading < 112.5) {
									directionText = "Heading East";
								} else if (heading >= 112.5 && heading < 157.5) {
									directionText = "Heading Southeast";
								} else if (heading >= 157.5 && heading < 202.5) {
									directionText = "Heading South";
								} else if (heading >= 202.5 && heading < 247.5) {
									directionText = "Heading Southwest";
								} else if (heading >= 247.5 && heading < 292.5) {
									directionText = "Heading West";
								} else if (heading >= 292.5 && heading < 337.5) {
									directionText = "Heading Northwest";
								}
							} else {
								directionText = "Not moving";
							}
							checkCheckpoints();
							// Update the HTML element with different navigation variables
							document.getElementById("currentLocation").innerHTML =
								"<strong><span class='material-icons' style='vertical-align: middle;'>bluetooth</span> Bluetooth:</strong> " + blueToothStatus + "<br>" +
								" <strong><span class='material-icons' style='vertical-align: middle;'>place</span> Latitude:</strong> " + latitude +
								"<strong> Longitude:</strong> " + longitude + "<br>" +
								"<strong><span class='material-icons' style='vertical-align: middle;'>location_city</span> Nearest street:</strong> " + streetName +
								"<strong><span class='material-icons' style='vertical-align: middle;'>pets</span><span class='material-icons' style='vertical-align: middle;'>person</span> Separation :</strong> " + distEachOther.toFixed(2) +" m" + "<br>" +
								" <strong><span class='material-icons' style='vertical-align: middle;'>explore</span> Direction:</strong> " + directionText +
								" <strong><span class='material-icons' style='vertical-align: middle;'>speed</span> Speed:</strong> " + speed.toFixed(2) + "ms/s" + "<br>" +
								" <strong><span class='material-icons' style='vertical-align: middle;'>directions_walk</span> Distance Walked: </strong> " + totalDistance.toFixed(2) +
								" m <strong>Avatar Actions:</strong> "+ partMoving + " " + directionMoving;
						},
						function (error) {
							console.error("Error getting current location: ", error);
						},
						options
					);
				} else {
					console.error("Geolocation is not supported by this browser.");
				}
			}

			// Function to calculate the distance between two coordinates using Haversine formula.
			function calculateDistance(lat1, lon1, lat2, lon2) {
				const earthRadius = 6371e3; // Earth radius in meters
				const phi1 = (lat1 * Math.PI) / 180; // Latitude in radians
				const phi2 = (lat2 * Math.PI) / 180; // Latitude in radians
				const deltaPhi = ((lat2 - lat1) * Math.PI) / 180;
				const deltaLambda = ((lon2 - lon1) * Math.PI) / 180;
				const a =
					Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) + Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);
				const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
				const distance = earthRadius * c; // Distance in meters
				return distance;
			}
			getCurrentLocation();
		</script>

		<script type="text/javascript">
			// Processing 4 sketch to visualize movements of the Avatar.
			let numPotentiometers = 8;
			let potValues;
			let lineColors;
			let backgroundColors;
			let isMovingUp = false;
			let isMovingDown = false;
			var previousPotValues = new Array(numPotentiometers);
			const cooldownDuration = 500; // 1 second
			let detectMovement = true;
			let startDetectMovement = false;
			let tagID = 0;

			function setup() {
				var avatarBTCanvas = createCanvas(windowWidth, windowHeight * 0.35);
				avatarBTCanvas.parent("avatarBTdiv");
				potValues = [0, 0, 0, 0, 0, 0, 0, 0]; // Initialize potValues array with default values
				lineColors = new Array(numPotentiometers);
				backgroundColors = new Array(numPotentiometers);
				setupColors();
				setupBackgroundColors();
			}
			function draw() {
				background(255);
				let lineHeight = height / numPotentiometers;
				let labelSize = min(width, height) * 0.03; // Responsive font size for labels
				for (let i = 0; i < numPotentiometers; i++) {
					let lineY = i * lineHeight + lineHeight / 2;
					// Draw the background rectangle
					noStroke();
					fill(backgroundColors[i]);
					rect(0, i * lineHeight, width, lineHeight);
					// Draw the line with different color for each
					strokeWeight(30);
					stroke(lineColors[i]);
					line(0, lineY, map(potValues[i], 0, 4095, 0, width * 0.55), lineY);
					// Display the corresponding value to the left of the line
					noStroke();
					fill(255);
					textFont("Roboto");
					textAlign(RIGHT, CENTER);
					textSize(labelSize);
					text(int(potValues[i]), map(potValues[i], 0, 4095, 0, width * 0.55) - 10, lineY);
				}
				// Draw vertical labels on the right side
				textAlign(RIGHT, CENTER);
				let labelFontSize = min(width, height) * 0.04; // Responsive font size for labels
				textFont("Roboto");
				textSize(labelFontSize);
				fill(255); // Set text color to white
				for (let i = 0; i < numPotentiometers; i++) {
					text(labels[i], width * 0.9, i * lineHeight + lineHeight / 2);
				}
				// Detect movement and display corresponding text
				if (startDetectMovement){
					checkMovement();
				}
			}

			// Function to receive data from JavaScript
			function receiveData(data) {
				let values = data.split(",");
				//console.log(values);
				tagID = values.pop(); // Remove and store the last element as tagID..
				readTag();
				if (values.length === numPotentiometers) { // Check if the length of values is 8
					for (let i = 0; i < values.length; i++) {
						potValues[i] = parseFloat(values[i]);
					}
				}
			}

			let previousMovements = {};

			// Function to check if two objects have the same keys and values..
			function objectsEqual(obj1, obj2) {
				const keys1 = Object.keys(obj1);
				const keys2 = Object.keys(obj2);

				if (keys1.length !== keys2.length) {
					return false;
				}

				for (let key of keys1) {
					if (obj1[key] !== obj2[key]) {
						return false;
					}
				}

				return true;
			}

			// Define variables for detecting movement in different body parts
				function handleMovement() {
				    // Define thresholds for movement detection
				    let movementThreshold = 13;

				    // Variables to track movement of different body parts
				    let movements = {};

				    // Mapping between labels and movements for hachi_BT or avatar_BT
				    let labelMovements;
				    if (deviceName === "hachi_BT") {
				        labelMovements = {
				            "HEAD": "headMoving",
				            "FRONT LEG": "leftLegMoving",
				            "BACK LEG": "rightLegMoving",
				            "LEFT SHOULDER": "leftShoulderMoving",
				            "RIGHT SHOULDER": "rightShoulderMoving",
				            "LEFT FOREARM": "leftForearmMoving",
				            "RIGHT FOREARM": "rightForearmMoving",
				            "TAIL": "waistMoving"
				        };
				    } else {
				        // Default labelMovements object for avatar_BT
				        labelMovements = {
				            "HEAD": "headMoving",
				            "LEFT LEG": "leftLegMoving",
				            "RIGHT LEG": "rightLegMoving",
				            "LEFT SHOULDER": "leftShoulderMoving",
				            "RIGHT SHOULDER": "rightShoulderMoving",
				            "LEFT FOREARM": "leftForearmMoving",
				            "RIGHT FOREARM": "rightForearmMoving",
				            "WAIST": "waistMoving"
				        };
				    }

				    // Check movement for each potentiometer
				    for (let i = 0; i < numPotentiometers; i++) {
				        let label = labels[i];
				        let movement = labelMovements[label];

						// Ignore if movement is null
						if (movement === null || movement === undefined) {
							continue;
						}

				        // Movement detection
				        if (potValues[i] < previousPotValues[i] - movementThreshold) {
				            movements[movement] = true; // Movement increases
				        } else if (potValues[i] > previousPotValues[i] + movementThreshold) {
				            movements[movement] = false; // Movement decreases
				        } else {
							movements[movement] = null; // No movement
						}
				    }

				    // Update previous potentiometer values for the next iteration.
				    previousPotValues = potValues.slice(0, numPotentiometers);

				    // Return the detected movement
				    if (Object.keys(movements).length > 0) { // Check if movements object is not empty
				        if (!objectsEqual(movements, previousMovements)) {
				            previousMovements = { ...movements }; // Make a copy of movements
				            //console.log(movements);
				            return movements;
				        }
				    }

				    return null; // No movement detected or movements haven't changed
				}

				let cachedMovementConditions = null;
				let previousPart = "none";
				let previousDirection = "none";

				async function checkMovement() {
					// Detect movement
					let movements = handleMovement();

					// Fetch movement conditions JSON file if not already cached...
					if (!cachedMovementConditions) {
						try {
							cachedMovementConditions = await $.get(moveSource);
							processMovementConditions(movements);
						} catch (error) {
							console.error('Error fetching movement conditions JSON:', error);
						}
					} else {
						processMovementConditions(movements);
					}

					function processMovementConditions(movements) {
						if (!movements) {
							//console.error("Movement data is null.");
							return;
						}
						// Iterate over movement conditions.
						cachedMovementConditions.forEach(condition => {
							let match = true;
							for (let key in condition.condition) {
								if (condition.condition[key] !== movements[key]) {
									match = false;
									break;
								}
							}
							if (match) {
								partMoving = condition.partMoving;
								directionMoving = condition.directionMoving;
							}
						});

						// Check if partMoving or directionMoving are different from their previous values and add movement to the sequence buffer.
						if (partMoving !== previousPart || directionMoving !== previousDirection) {
							// Add movement to the sequence buffer
							console.log(partMoving+" "+directionMoving);
							if (noNarrative){
								window.success_Sound.play();
								displayText(partMoving+" "+directionMoving);
							}
							previousPart = partMoving;
							previousDirection = directionMoving;
							trackMovementSequences();
						} else {
							return;
						}
					}
				}

				let movementBuffer = [];
				let cachedMovePatterns;

				// Function to track movement sequences and compare them against patterns
				async function trackMovementSequences() {
					try {
						const currentSequence = { partMoving, directionMoving };

						// Check if the current sequence is different from the previous one
						if (
							movementBuffer.length > 0 &&
							movementBuffer[movementBuffer.length - 1].partMoving === partMoving &&
							movementBuffer[movementBuffer.length - 1].directionMoving === directionMoving
						) {
							return; // Exit early if the sequence is the same as the previous one
						}

						movementBuffer.push(currentSequence);

						// Limit the buffer to store only the last 5 variations
						if (movementBuffer.length > 5) {
							movementBuffer.shift(); // Remove the oldest variation
						}

						const patterns = await fetchJSONFile(movePatterns, cachedMovePatterns);
						//const patterns = await fetchMovementPatterns();
						for (const pattern of patterns) {
							if (checkPatternInBuffer(pattern.pattern)) {
								window.success_Sound.play();
								console.log(`Pattern matched: ${pattern.patternName}`);
								patternMovement = pattern.patternName;
								if (noNarrative){
									displayText(patternMovement);
								}
								// Clear the buffer after a match
								movementBuffer = [];
								setTimeout(resetVariables, 4000); // 3000 milliseconds = 3 seconds
								return;
							}
						}
					} catch (error) {
						console.error(error);
					}
				}

				function resetVariables() {
					directionMoving = "none";
					partMoving = "none";
					patternMovement = "none";
				}

				// Function to check if a pattern exists in the movement buffer
				function checkPatternInBuffer(pattern) {
					const bufferLength = movementBuffer.length;
					if (bufferLength < pattern.length) {
						return false; // Not enough movements in the buffer for pattern matching
					}

					// Check the last 'pattern.length' movements in the buffer
					const bufferSlice = movementBuffer.slice(-pattern.length);
					for (let i = 0; i < pattern.length; i++) {
						if (pattern[i].partMoving !== bufferSlice[i].partMoving ||
							pattern[i].directionMoving !== bufferSlice[i].directionMoving) {
							return false; // Pattern doesn't match
						}
					}
					return true; // Pattern matched
				}

				let cachedPatterns; // Variable to cache the fetched patterns data
				async function fetchMovementPatterns() {
					try {
						if (cachedPatterns) {
							// If data is already cached, return it immediately
							return cachedPatterns;
						} else {
							// If data is not cached, fetch it from the server
							const patterns = await $.get(movePatterns);
							cachedPatterns = patterns; // Cache the fetched data
							return patterns;
						}
					} catch (error) {
						console.error(error);
						return []; // Return an empty array in case of error
					}
				}

				var timeoutID; // Variable to hold the timeout ID.
				var previousMessage = ""; // Variable to store the previous message
				var previousLatitude;
				var previousLongitude;
				var previousPartMoving;
				var previousDirectionMoving;
				var timeOfDay;

				var fullMessage;
				var messageID = ""; // Global variable to store the message ID

				function displayText(message) {
					var messageDisplayDiv = document.getElementById("messageDisplayDiv");
					var delimiterIndex = message.indexOf("/"); // Find the index of the delimiter "/"

					// Check if speaking is true, if so, exit early.
					if (speaking) {
						return;
					}

					if (delimiterIndex !== -1) { // Check if the delimiter exists
						messageID = message.substring(0, delimiterIndex); // Store the message ID globally
						var fullMessage = message.substring(delimiterIndex + 1).trim(); // Extract the message text after the delimiter
						clearTimeout(timeoutID);
						speakMessage(fullMessage);
						updateDisplay(fullMessage);
					} else { // If the delimiter does not exist
						messageID = ""; // Set message ID to an empty string globally
						var fullMessage = message.trim(); // The full message is the entire input
						clearTimeout(timeoutID);
						speakMessage(fullMessage);
						updateDisplay(fullMessage);
					}
				}

				// Update display
				function updateDisplay(displayMessage) {
					try {
						// Set the text content
						messageDisplayDiv.textContent = displayMessage;

						// Check if message is not empty to show the overlay
						messageDisplayDiv.style.display = displayMessage.trim() !== "" ? "block" : "none";

						if (displayMessage.trim() !== "") {
							// Create a close button
							var closeButton = document.createElement("dismissButton");
							closeButton.classList.add("button"); // Add your button class here
							closeButton.id = "dismissButton"; // Set the id for styling
							closeButton.textContent = "Dismiss";
							closeButton.addEventListener("click", function() {
								messageDisplayDiv.textContent = ""; // Clear the text
								messageDisplayDiv.style.display = "none"; // Hide the overlay after clearing the text
								closeButton.remove(); // Remove the close button
							});
							// Append the close button to messageDisplayDiv
							messageDisplayDiv.appendChild(closeButton);
						}
						// Set a timeout to clear the text after 3 seconds or until speaking becomes false
						var timeoutCallback = function() {
							if (!speaking) {
								messageDisplayDiv.textContent = ""; // Clear the text
								messageDisplayDiv.style.display = "none"; // Hide the overlay after clearing the text
								timeoutID = setTimeout(timeoutCallback, 1000); // Check again after 1 second
							}
						};
						timeoutID = setTimeout(timeoutCallback, 3000);
					} catch (error) {
						// Catch and log any errors that occur within the function
						console.error("An error occurred:", error);
					}
				}

				async function fetchJSONFile(filename, cachedVariable) {
					try {
						if (!cachedVariable) {
							const response = await fetch(filename);
							if (!response.ok) {
								throw new Error('Network response was not ok');
							}
							const jsonData = await response.json(); // Fetch JSON data
							cachedVariable = jsonData; // Cache the fetched JSON data in the specified variable
							return jsonData;
						} else {
							return cachedVariable; // Return cached data if available
						}
					} catch (err) {
						console.error('Error fetching JSON file:', err);
						return null;
					}
				}

				let cachedSentences;

				// Variable to store the last spoken message
				let lastSpokenMessage = '';
				let speaking = false;

				function speakMessage(fullMessage) {
				// Check if the message is the same as the last spoken message
					if (fullMessage === lastSpokenMessage) {
						console.log("Message already spoken.");
						return; // Exit the function without speaking again
					}
					// Check if currently speaking
					if (speaking) {
						console.log("Already speaking, new message ignored.");
						return;
					}
					// Create a new instance of SpeechSynthesisUtterance.
					const utterance = new SpeechSynthesisUtterance(fullMessage);
					// Filter available voices to find Karen's voice in Australian English
					const karenVoice = speechSynthesis.getVoices().find(voice => voice.name === 'Karen' && voice.lang === 'en-AU');
					// Set the voice to Karen's voice if found, otherwise use the default voice
					utterance.voice = karenVoice || speechSynthesis.getVoices()[0];
					// Speak the message
					speechSynthesis.speak(utterance);
					utterance.onstart = function() {
						speaking = true;
						console.log("Currently speaking");
						// Update the last spoken message
						lastSpokenMessage = fullMessage;
					};
					utterance.onend = function() {
						console.log("End speaking");
						speaking = false;
					}
					// Event handler for speech synthesis error
					utterance.onerror = function(event) {
						speaking = false; // Reset speaking flag
						console.error("Speech synthesis error:", event.error);
					};
				}

				function checkSpeechSynthesis() {
					// Check if speechSynthesis object is available
					if ('speechSynthesis' in window) {
						// Check if speaking flag is true
						if (speechSynthesis.speaking) {
							speaking = true;
						} else {
							speaking = false;
						}
					} else {
						console.log("Speech synthesis is not supported in this browser.");
					}
				}

				// Call the function periodically (e.g., every 5 seconds).
				setInterval(checkSpeechSynthesis, 1000); // Adjust the interval as needed

				let weatherDescription = null;

				var noNarrative;
				var previousTagID = ""; // Variable to store the previous tagID

				let cachedTagInfo;
				async function readTag() {
					try {
						if (tagID === previousTagID || tagID === "0" || speaking) {
							// If tagID is the same as the previous one or is 0, do nothing
							return;
						} else {
							// Fetch tag information asynchronously
							const tagInfo = await fetchJSONFile(tagSource, cachedTagInfo);

							if (tagInfo && tagInfo.tags.hasOwnProperty(tagID)) {
								// Update previousTagID to the current tagID
								previousTagID = tagID;
								//success_Sound.play();
								window.success_Sound.play();
								console.log(tagID);

								// Retrieve tag information based on tagID
								const tagData = tagInfo.tags[tagID];

								// Execute function specified in the JSON
								if (tagInfo.tags[tagID].function) {
									eval(tagInfo.tags[tagID].function);
								}

								// Update variables based on fetched tagData
								if (tagData.variable && typeof tagData.boolean === 'boolean') {
									// Dynamically update variables based on tagData
									window[tagData.variable] = tagData.boolean;
								}
								displayText(tagData.displayText);
								//partMoving = tagData.partMoving;
								//directionMoving = tagData.directionMoving;

							} else {
								window.alert_Sound.play();
								console.error('Tag information not found.');
								return;
							}
						}
					} catch (err) {
						console.error('Error reading tag:', err);
					}
				}

				let cachedCheckpoints;
				let lastCheckedIndex = 0; // Initialize the index of the last checked key
				let currentCheckpoint = "none";
				let chkPointDistance = 0;

				async function checkCheckpoints() {
					console.debug("Checking checkpoint");
					const radius = 10; // 10 meters radius

					// Load checkpoints from the JSON file
					const locations = await fetchJSONFile(checkpointsSource, cachedCheckpoints);

					// Ensure locations is an array and not empty
					if (Array.isArray(locations) && locations.length > 0) {
						const checkpoints = locations[0].checkpoints;

						// Ensure checkpoints is an object
						if (typeof checkpoints === 'object' && checkpoints !== null) {
							const checkpointKeys = Object.keys(checkpoints);

							// Ensure lastCheckedIndex is within bounds
							if (lastCheckedIndex < checkpointKeys.length) {
								const currentCheckpointKey = checkpointKeys[lastCheckedIndex];
								console.log('Current Checkpoint Set:', currentCheckpointKey);

								// Process checkpoints within the current set
								const checkpointSet = checkpoints[currentCheckpointKey];
								const checkpointIndex = deviceName === "hachi_BT" ? 1 : 0;

								if (checkpointSet && checkpointSet.length > checkpointIndex) {
									const checkpoint = checkpointSet[checkpointIndex];
									const distance = calculateDistance(latitude, longitude, checkpoint.latitude, checkpoint.longitude);
									chkPointDistance = distance.toFixed(2);
									console.log('Checkpoint Latitude:', checkpoint.latitude, 'Checkpoint Longitude:', checkpoint.longitude, 'Distance:', chkPointDistance);

									if (distance <= radius) {
										console.log('Checkpoint reached:', checkpoint.text);
										currentCheckpoint = checkpoint.text;
										window.success_Sound.play();
										lastCheckedIndex++; // Move to the next key
										return; // Exit the function when a checkpoint is reached
									}
								}
								//console.log("No checkpoints reached in the current set.");
							} else {
								console.log("No more checkpoint sets to check.");
							}
						}
					}
				}

				function setupColors() {
					lineColors[0] = color(204, 204, 0); // Dark Yellow
					lineColors[1] = color(204, 204, 0); // Dark Yellow
					lineColors[2] = color(255, 0, 0); // Red
					lineColors[3] = color(204, 204, 0); // Dark Yellow
					lineColors[4] = color(204, 204, 0); // Dark Yellow
					lineColors[5] = color(0, 255, 0); // Bright Green
					lineColors[6] = color(0, 128, 0); // Grass Green
					lineColors[7] = color(0, 128, 0); // Grass Green
				}
				function setupBackgroundColors() {
					backgroundColors[0] = color(0, 0, 0); // 0% black
					backgroundColors[1] = color(0, 0, 0); // 0% black
					backgroundColors[2] = color(0, 0, 0, 200); // 90% black
					backgroundColors[3] = color(0, 0, 0, 230); // 75% black
					backgroundColors[4] = color(0, 0, 0, 230); // 60% black
					backgroundColors[5] = color(0, 0, 0, 128); // 60% black
					backgroundColors[6] = color(0, 0, 0, 100); // 60% black
					backgroundColors[7] = color(0, 0, 0, 100); // 60% black
				}
		</script>

		<script type="module">
			import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.9.0/firebase-app.js'
			import  { getDatabase, ref, set, onValue, off, update } from 'https://www.gstatic.com/firebasejs/10.9.0/firebase-database.js'

			// Your Firebase configuration
			const firebaseConfig = {
				apiKey: "AIzaSyDWeHUOXcHSp01pLYXY8HQm-l8e7ldqeRA",
				authDomain: "searchingforus.firebaseapp.com",
				databaseURL: "https://searchingforus-default-rtdb.europe-west1.firebasedatabase.app",
				projectId: "searchingforus",
				storageBucket: "searchingforus.appspot.com",
				messagingSenderId: "1074186074798",
				appId: "1:1074186074798:web:316b5662099ab3b0e48b3f"
			};

			// Initialize Firebase
			const app = initializeApp(firebaseConfig);

			// Reference to your Firebase Realtime Database
			const database = getDatabase(app);

			// Function to write data to the database

			// Variables to store previous values of latitude, longitude, and currentCheckpoint
			let prevLatitude = null;
			let prevLongitude = null;
			let prevCurrentCheckpoint = null;
			let prevMovement = null;
			let prevTagInteraction = null;
			let prevHeading = null;
			let prevStatus = null;
			let prevSpeed = null;
			let prevSpeaking = null


			// Function to write data to the database
			function writeToDatabase() {
			    // Check if variables are not null or empty
			    if (latitude && longitude && currentCheckpoint) {
			        // Check if variables have changed since the last write operation
			     if (latitude !== prevLatitude ||
			         longitude !== prevLongitude ||
			         currentCheckpoint !== prevCurrentCheckpoint ||
			         patternMovement !== prevMovement ||
			         tagID !== prevTagInteraction ||
					 blueToothStatus !== prevStatus ||
					 speaking !== prevSpeaking ||
			         directionText !== prevHeading) {

			            // Update previous values
			            prevLatitude = latitude;
			            prevLongitude = longitude;
			            prevCurrentCheckpoint = currentCheckpoint;
						prevMovement = patternMovement;
						prevTagInteraction = tagID;
						prevHeading = directionText;
						prevStatus = blueToothStatus;
						prevSpeed = speed;
						prevSpeaking = speaking;
			            // Determine the database name based on the deviceName
			            const databaseName = (deviceName === 'hachi_BT') ? 'hachi_data' : 'avatar_data';

			            // Determine the variable names based on the deviceName
			            const latitudeVar = (deviceName === 'hachi_BT') ? 'hachi_latitude' : 'avatar_latitude' ;
			            const longitudeVar = (deviceName === 'hachi_BT') ? 'hachi_longitude' : 'avatar_longitude';
						const headingVar = (deviceName === 'hachi_BT') ? 'hachi_heading' : 'avatar_heading';
			            const checkpointVar = (deviceName === 'hachi_BT') ? 'hachi_checkpoint' :'avatar_checkpoint' ;
						const checkDistVar = (deviceName === 'hachi_BT') ? 'hachi_checkpoint_dist' : 'avatar_checkpoint_dist';
						const movementVar = (deviceName === 'hachi_BT') ? 'hachi_movement' :'avatar_movement' ;
						const partMovementVar = (deviceName === 'hachi_BT') ? 'hachi_part_mov' :'avatar_part_mov' ;
						const dirMovementVar = (deviceName === 'hachi_BT') ? 'hachi_part_dir' :'avatar_part_dir' ;
						const tagInteractionVar = (deviceName === 'hachi_BT') ? 'hachi_tag' :'avatar_tag' ;
						const statusVar = (deviceName === 'hachi_BT') ? 'hachi_status' :'avatar_status' ;
						const speedVar = (deviceName === 'hachi_BT') ? 'hachi_speed' :'avatar_speed' ;
						const speakingVar = (deviceName === 'hachi_BT') ? 'hachi_narrating' :'avatar_narrating' ;

			            // Write variables to the database
			            update(ref(database, databaseName), {
			                [latitudeVar]: latitude,
			                [longitudeVar]: longitude,
							[headingVar]: directionText,
			                [checkpointVar]: currentCheckpoint,
							[checkDistVar]: chkPointDistance,
							[movementVar]: patternMovement,
							[partMovementVar]: partMoving,
							[dirMovementVar]: directionMoving,
							[tagInteractionVar]: tagID,
							[statusVar]: blueToothStatus,
							[speedVar]: speed.toFixed(2),
							[speakingVar]: messageID+speaking
			            }).then(() => {
			                //console.log("Variables written to the database successfully!");
			            }).catch((error) => {
			                console.error("Error writing variables to the database:", error);
			            });
			        } else {
			            //console.log("Variables have not changed. Data not written to the database.");
			        }
			    } else {
			        //console.log("One or more variables are null or empty. Data not written to the database.");
			    }
			}

			var other_latitude=null;
			var other_longitude=null;
			let previousPassage = ''; // Initialize previous passage value

			// Function to read data from the database
			function readFromDatabase(deviceName) {
				// Read from the other database based on deviceName
				const otherDatabaseName = (deviceName === 'hachi_BT') ? 'avatar_data': 'hachi_data';
				const otherLatitudeVar = (deviceName === 'hachi_BT') ? 'avatar_latitude' : 'hachi_latitude';
				const otherLongitudeVar = (deviceName === 'hachi_BT') ? 'avatar_longitude' : 'hachi_longitude' ;
				const databaseName = (deviceName === 'hachi_BT') ? 'hachi_data' : 'avatar_data';
				const myPassage = (deviceName === 'hachi_BT') ? 'hachi_passage' :'avatar_passage' ;
				const myStreet = (deviceName === 'hachi_BT') ? 'hachi_street' :'avatar_street' ;

				// Subscribe to real-time updates for variables from the other database
				onValue(ref(database, otherDatabaseName), (snapshot) => {
					const otherData = snapshot.val();
					if (otherData) {
						other_latitude = otherData[otherLatitudeVar];
						other_longitude = otherData[otherLongitudeVar];
						distEachOther = calculateDistance(latitude, longitude, other_latitude, other_longitude);
						//console.log("Variables read from the other database successfully!");
					} else {
						console.log("No data found in the other database.");
					}
				});

				// Subscribe to real-time updates for variables from own database
				onValue(ref(database, databaseName), (snapshot) => {
				const myData = snapshot.val();
				if (myData) {
					const passage = myData[myPassage];
					console.log(databaseName);
					if (passage !== previousPassage) { // Compare with previous passage
						console.log(String(passage));
						displayText(String(passage));
						previousPassage = passage; // Update previous passage
					}
					streetName = myData[myStreet];
				} else {
					console.log("No data found in the own database.");
				}
			});
			}

			function toggleDeviceName2() {
				var checkbox = document.getElementById("hachiCheckbox");
				const databaseName = (deviceName === 'hachi_BT') ? 'avatar_data' : 'hachi_data';
				if (checkbox.checked) {
					off(ref(database, databaseName));
					//database.ref('avatar_data').off();
				} else {
					off(ref(database, databaseName));
					//database.ref('hachi_data').off();
				}
			}

			setInterval(() => {
				toggleDeviceName2();
				console.log(deviceName);
				writeToDatabase();
			}, 1000);
			readFromDatabase(deviceName); // Read data after writing
		</script>
	</body>
</html>
